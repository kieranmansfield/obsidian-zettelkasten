import { App, Modal, ButtonComponent, Setting } from "obsidian";
import { ZettelTreeImmutable } from "../../core/ZettelTreeImmutable";
import type { ZettelNode } from "../../core/ZettelTreeImmutable";
import type BoxManager from "../../core/BoxManager";
export class ReorderModal extends Modal {
  private simpleForest:any[] = [];
  constructor(app:App, forest: readonly ZettelNode[], private box:any, private onApply:(res:any)=>Promise<void>){ super(app); this.simpleForest = forest.map(n=>({ id: n.id.toString(), basename: n.file?.basename, path: n.file?.path, children: n.children.map(c=>({ id:c.id.toString(), basename:c.file?.basename, path:c.file?.path, children: c.children })) })); }
  onOpen(){ const { contentEl } = this; contentEl.empty(); contentEl.createEl('h2',{text:`Reorder — ${this.box.name}`}); const treeWrap = contentEl.createEl('div'); treeWrap.style.maxHeight = '60vh'; treeWrap.style.overflow = 'auto'; treeWrap.appendChild(this.buildUL(this.simpleForest)); const preview = contentEl.createEl('div'); const footer = contentEl.createDiv(); const btnPreview = new ButtonComponent(footer); btnPreview.setButtonText('Preview (Dry Run)').onClick(()=>{ this.handlePreview(preview); }); const btnApply = new ButtonComponent(footer); btnApply.setButtonText('Apply').setCta().onClick(async()=>{ await this.handleApply(); }); new Setting(contentEl).addButton(b=>b.setButtonText('Close').onClick(()=>this.close())); }
  onClose(){ this.contentEl.empty(); }
  private nodeToSimple(n:any){ return { id: n.id, basename: n.file?.basename, path: n.file?.path, children: n.children.map((c:any)=>this.nodeToSimple(c)) }; }
  private buildUL(nodes:any[]){ const ul = document.createElement('ul'); ul.style.listStyle='none'; ul.style.paddingLeft='14px'; for(const node of nodes){ const li = document.createElement('li'); li.className='zk-node'; li.draggable=true; li.dataset.id = node.id; li.style.margin='6px 0'; li.style.padding='6px'; li.style.border='1px solid var(--background-modifier-border)'; li.style.borderRadius='6px'; const label = document.createElement('div'); label.textContent = node.id + (node.basename?` — ${node.basename}`:''); li.appendChild(label); const childUL = this.buildUL(node.children||[]); li.appendChild(childUL); label.addEventListener('dragover',(e)=>{ e.preventDefault(); li.classList.add('zk-dragover'); }); label.addEventListener('dragleave',()=>li.classList.remove('zk-dragover')); label.addEventListener('drop',(e)=>{ e.preventDefault(); li.classList.remove('zk-dragover'); const moving = e.dataTransfer?.getData('text/plain'); const makeSibling = e.shiftKey; this.moveNode(moving, node.id, makeSibling ? 'sibling-after' : 'child'); this.rebuild(); }); ul.addEventListener('dragover',(e)=>e.preventDefault()); ul.addEventListener('drop',(e)=>{ e.preventDefault(); const moving = e.dataTransfer?.getData('text/plain'); const parentLi = ul.parentElement && ul.parentElement.classList.contains('zk-node') ? ul.parentElement as HTMLElement : null; const parentId = parentLi?.dataset?.id ?? ''; if(parentId) this.moveNode(moving, parentId, 'child'); else this.moveNode(moving, '', 'top'); this.rebuild(); }); ul.appendChild(li); } return ul; }
  private rebuild(){ const { contentEl } = this; contentEl.empty(); contentEl.createEl('h2',{text:`Reorder — ${this.box.name}`}); const treeWrap = contentEl.createEl('div'); treeWrap.style.maxHeight='60vh'; treeWrap.style.overflow='auto'; treeWrap.appendChild(this.buildUL(this.simpleForest)); const preview = contentEl.createEl('div'); const footer = contentEl.createDiv(); const btnPreview = new ButtonComponent(footer); btnPreview.setButtonText('Preview (Dry Run)').onClick(()=>{ this.handlePreview(preview); }); const btnApply = new ButtonComponent(footer); btnApply.setButtonText('Apply').setCta().onClick(async()=>{ await this.handleApply(); }); new Setting(contentEl).addButton(b=>b.setButtonText('Close').onClick(()=>this.close())); }
  private moveNode(movingId:string, targetId:string, mode:'child'|'sibling-after'|'top'){ const node = this.extract(movingId, this.simpleForest); if(!node) return; if(mode==='top'){ this.simpleForest.push(node); return; } if(!targetId){ this.simpleForest.push(node); return;} const target = this.find(targetId, this.simpleForest); if(!target){ this.simpleForest.push(node); return;} if(mode==='child'){ target.children = target.children||[]; target.children.push(node); return; } if(mode==='sibling-after'){ const arr = this.findParentArray(targetId, this.simpleForest); if(!arr){ const idx = this.simpleForest.findIndex((s:any)=>s.id===targetId); this.simpleForest.splice(idx+1,0,node); } else { const idx = arr.findIndex((s:any)=>s.id===targetId); arr.splice(idx+1,0,node); } } }
  private extract(id:string, arr:any[]): any|null { for(let i=0;i<arr.length;i++){ if(arr[i].id===id) return arr.splice(i,1)[0]; const nested = this.extract(id, arr[i].children); if(nested) return nested; } return null; }
  private find(id:string, arr:any[]): any|null{ for(const n of arr){ if(n.id===id) return n; const ch = this.find(id, n.children); if(ch) return ch; } return null; }
  private findParentArray(childId:string, arr:any[]): any[]|null{ for(const n of arr){ if(n.children?.some((c:any)=>c.id===childId)) return n.children; const deeper = this.findParentArray(childId, n.children); if(deeper) return deeper; } if(arr.some((x:any)=>x.id===childId)) return arr; return null; }
  private flattenToFileRecords(){ const out:any[]=[]; const walk=(nodes:any[])=>{ for(const n of nodes){ out.push({ idString: n.id, path: n.path ?? `${this.box.folder}/${n.id}.md`, basename: n.basename ?? `${n.id}.md` }); if(n.children?.length) walk(n.children); } }; walk(this.simpleForest); return out; }
  private handlePreview(container?:HTMLElement){ const records = this.flattenToFileRecords(); const zt = new ZettelTreeImmutable(); const forest = ZettelTreeImmutable.buildForestFromFiles(records); const result = ZettelTreeImmutable.compactForest(forest); const pre = document.createElement('pre'); const lines:string[]=[]; lines.push('ID renames:'); for(const [o,n] of result.idRenameMap.entries()) lines.push(`${o} -> ${n}`); lines.push(''); lines.push('File renames:'); for(const [o,n] of result.filePathRenameMap.entries()) lines.push(`${o} -> ${n}`); pre.textContent = lines.join('\n') || '(no renames)'; if(container){ container.empty(); container.appendChild(pre);} else { const c = this.contentEl.createDiv(); c.appendChild(pre); } }
  private async handleApply(){ const records = this.flattenToFileRecords(); const forest = ZettelTreeImmutable.buildForestFromFiles(records); const result = ZettelTreeImmutable.compactForest(forest); await this.onApply(result); }
}
export default ReorderModal
