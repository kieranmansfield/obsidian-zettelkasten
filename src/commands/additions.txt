To add sequence navigation, add these changes:

1. In registerCommands(), after line 22 (registerReorderSequenceCommand), add:
		this.registerNextSequenceCommand();
		this.registerPreviousSequenceCommand();

2. Before the final closing brace of the class (around line 2100), add these three methods:

	/**
	 * Gets the root zettel ID (without any suffix)
	 * Example: "20251114154532123a1" â†’ "20251114154532123"
	 */
	private getRootZettelId(zettelId: string): string {
		// Extract just the numeric timestamp (13+ digits)
		const match = zettelId.match(/^(\d{13,})/);
		return match ? match[1] : zettelId;
	}

	/**
	 * Gets all parent-level zettels in a specific folder
	 * Parent-level means IDs with no suffix (just the timestamp)
	 */
	private getParentLevelZettelsInFolder(
		folder: TFolder | null,
	): TFile[] {
		if (!folder) {
			return [];
		}

		const allFiles = this.plugin.app.vault.getMarkdownFiles();
		const parentZettels: TFile[] = [];

		for (const file of allFiles) {
			// Check if file is in the same folder
			if (file.parent?.path !== folder.path) {
				continue;
			}

			if (this.shouldIgnoreFile(file)) {
				continue;
			}

			const id = this.extractZettelId(file.basename);
			if (!id) {
				continue;
			}

			// Check if this is a parent-level zettel (ID is just numbers, no suffix)
			if (/^\d+$/.test(id)) {
				parentZettels.push(file);
			}
		}

		// Sort by ID (chronological order)
		parentZettels.sort((a, b) => {
			const idA = this.extractZettelId(a.basename) || "";
			const idB = this.extractZettelId(b.basename) || "";
			return idA.localeCompare(idB);
		});

		return parentZettels;
	}

	/**
	 * Registers the "Next Sequence" command
	 * Opens the next parent-level zettel in the current folder
	 */
	private registerNextSequenceCommand(): void {
		this.plugin.addCommand({
			id: "next-sequence",
			name: "Go to Next Sequence",
			icon: "chevron-right",
			callback: async () => {
				const activeFile =
					this.plugin.app.workspace.getActiveFile();

				if (!activeFile) {
					new Notice("No active file");
					return;
				}

				const currentId = this.extractZettelId(activeFile.basename);
				if (!currentId) {
					new Notice("Current file is not a zettel");
					return;
				}

				// Get the root ID (parent-level, no suffix)
				const currentRootId = this.getRootZettelId(currentId);

				// Find all parent-level zettels in the same folder
				const parentZettels = this.getParentLevelZettelsInFolder(
					activeFile.parent,
				);

				if (parentZettels.length === 0) {
					new Notice("No sequences found in this folder");
					return;
				}

				// Find current sequence index
				const currentIndex = parentZettels.findIndex(
					(file) =>
						this.extractZettelId(file.basename) ===
						currentRootId,
				);

				if (currentIndex === -1) {
					new Notice("Could not find current sequence");
					return;
				}

				// Get next sequence (wrap around to first if at end)
				const nextIndex =
					(currentIndex + 1) % parentZettels.length;
				const nextFile = parentZettels[nextIndex];

				if (nextFile) {
					await this.plugin.app.workspace
						.getLeaf()
						.openFile(nextFile);
				}
			},
		});
	}

	/**
	 * Registers the "Previous Sequence" command
	 * Opens the previous parent-level zettel in the current folder
	 */
	private registerPreviousSequenceCommand(): void {
		this.plugin.addCommand({
			id: "previous-sequence",
			name: "Go to Previous Sequence",
			icon: "chevron-left",
			callback: async () => {
				const activeFile =
					this.plugin.app.workspace.getActiveFile();

				if (!activeFile) {
					new Notice("No active file");
					return;
				}

				const currentId = this.extractZettelId(activeFile.basename);
				if (!currentId) {
					new Notice("Current file is not a zettel");
					return;
				}

				// Get the root ID (parent-level, no suffix)
				const currentRootId = this.getRootZettelId(currentId);

				// Find all parent-level zettels in the same folder
				const parentZettels = this.getParentLevelZettelsInFolder(
					activeFile.parent,
				);

				if (parentZettels.length === 0) {
					new Notice("No sequences found in this folder");
					return;
				}

				// Find current sequence index
				const currentIndex = parentZettels.findIndex(
					(file) =>
						this.extractZettelId(file.basename) ===
						currentRootId,
				);

				if (currentIndex === -1) {
					new Notice("Could not find current sequence");
					return;
				}

				// Get previous sequence (wrap around to last if at start)
				const prevIndex =
					(currentIndex - 1 + parentZettels.length) %
					parentZettels.length;
				const prevFile = parentZettels[prevIndex];

				if (prevFile) {
					await this.plugin.app.workspace
						.getLeaf()
						.openFile(prevFile);
				}
			},
		});
	}
